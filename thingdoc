#!/usr/bin/env python
#
# ThingDoc - things comment parser - http://thingdoc.org/
# Copyright (C) 2011 Josef Prusa <iam@josefprusa.cz>
# Copyright (C) 2011 Pavol Rusnak <stick@gk2.sk>
# See the file AUTHORS for all contributions
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

VERSION = '1.0'

import optparse
import os
import sys

class Thing:

	def __init__(self):
		self.id = None          # unique id, root has id = 0 (numeric) which cannot be overriden
		self.name = None        # name of the thing
		self.common = False     # is this thing common?
		self.assembled = False  # is this thing assembled?
		self.category = ''      # category of the thing
		self.type = ''          # type of the thing (more detailed than category, e.g. RP, fastener, etc)
		self.assembly = []      # assembly instructions
		self.since = ''         # since when does the thing exist (can be YYYY-MM-DD or some tag, e.g. "Mendel")
		self.comment = []       # comments
		self.image = None       # if none is specified then images/{id}.jpg is used
		self.using = []         # list of dependencies (their {id}s)
		self.price = None       # price of the thing (in $)
		self.weight = None      # weight of the thing (in grams)
		self.desc = []          # description of the thing


def warning(string):
	print >> sys.stderr, 'Warning:', string


def error(string):
	print >> sys.stderr, 'Error:', string


def fatal(string):
	print >> sys.stderr, 'Fatal:', string
	sys.exit(1)


def process_file(absname, things):

	try:
		f = open(absname, 'r')
	except IOError:
		fatal('Cannot open file %s' % absname)

	thing = None
	linenum = 0
	for line in f:
		linenum += 1
		if line.startswith('/**'):
			if thing:
				error('Start of the comment (/**) found but the previous one is still open (%s:%d)' % (absname, linenum))
			thing = Thing()
			continue
		if line.startswith(' */'):
			if not thing:
				error('End of the comment ( */) found but there is no previous open one (%s:%d)' % (absname, linenum))
				continue
			if not thing.id:
				error('Missing mandatory attribute @id (%s:%d)' % (absname, linenum))
			if not thing.name:
				error('Missing mandatory attribute @name (%s:%d)' % (absname, linenum))
			if thing.id and thing.name:
				if things.has_key(thing.id):
					if thing.id == 1:
						fatal('More than one @root detected!')
					else:
						error("Duplicate thing id: '%s' (%s:%d)" % (thing.id, absname, linenum))
				else:
					things[ thing.id ] = thing
			thing = None
			continue
		if not thing:
			continue  # not in a comment
		if not line.startswith(' * '):
			error('Comment line does not start with a " * " (%s:%d)' % (absname, linenum))
			continue
		(key, _, value) = line[3:].strip().partition(' ')
		if   key == '@id':
			thing.id = value
		elif key == '@name':
			thing.name = value
		elif key == '@root':
			thing.id = 1
		elif key == '@common':
			thing.common = True
		elif key == '@assembled':
			thing.assembled = True
		elif key == '@since':
			thing.since = value
		elif key == '@category':
			thing.category = value
		elif key == '@type':
			thing.type = value
		elif key == '@assembly':
			thing.assembly.append(value)
		elif key == '@comment':
			thing.comment.append(value)
		elif key == '@image':
			thing.image = value
		elif key == '@using':
			(cnt, _, id) = value.partition(' ')
			try:
				cnt = int(cnt)
			except:
				id = cnt
				cnt = 1
			thing.using.append( (cnt, id) )
		elif key == '@price':
			thing.price = float(value)
		elif key == '@weight':
			thing.weight = float(value)
		else:
			thing.desc.append(key + ' ' + value)
	f.close()


def generate_tree(indir):

	things = {}
	for root, dirs, files in os.walk(os.path.abspath(indir)):
		dirs[:] = [d for d in dirs if not d.startswith('.')]
		for name in files:
			# skip if the file is not supported document
			if not os.path.splitext(name)[1] in ['.scad', '.tdoc']:
				continue
			absname = os.path.join(root, name)
			process_file(absname, things)
	return things


def check_tree(tree):

	if not tree.has_key(1):
		fatal('Nothing was declared as @root')

	# do BFS on dependency graph
	used = []
	missing = []
	queue = [1]
	while queue:
		thing = queue.pop()
		if not thing in tree.iterkeys():
			if not thing in missing:
				missing.append(thing)
			continue
		if not thing in used:
			used.append(thing)
			queue += map(lambda x: x[1], tree[thing].using)

	# handle unused things
	for thing in tree.iterkeys():
		if not thing in used:
			warning("Thing '%s' is defined but unused" % thing)

	valid = True

	# handle undefined things
	for thing in missing:
		parents = []
		for k, v in tree.iteritems():
			if thing in map(lambda x: x[1], v.using):
				parents.append(k == 1 and '@root' or ("'" + k + "'"))
		parents.sort()
		error("Thing '%s' is not defined and required by: %s" % (thing, ', '.join(parents)))
		valid = False

	# detect oriented cycles
	todo = tree.keys()
	while todo:
		node = todo.pop()
		stack = [node]
		while stack:
			top = stack[-1]
			for node in map(lambda x: x[1], tree[top].using):
				if node in stack:
					error("Oriented cycle detected: '%s'" % ("' -> '".join(stack[stack.index(node):] + [node])))
					valid = False
					todo = []
					stack = []
					break
				if node in todo:
					stack.append(node)
					todo.remove(node)
					break
			else:
				node = stack.pop()

	if not valid:
		fatal('Tree validation failed, see errors above')


def print_tree(tree):

	queue = [(0, 1, -1)]
	while queue:
		(cnt, id, level) = queue.pop(0)
		if id == 1:
			print '@root', '(' + tree[id].name + ')'
		else:
			print level * '  ', '-', str(cnt) + 'x', tree[id].id, '(' + tree[id].name + ')'
		queue = map(lambda x: (x[0], x[1], level + 1), tree[id].using) + queue


def graphviz_tree(tree):

	print 'digraph thingdoc {'
	print '\tnode [color=lightblue, style=filled];'
	print '\tedge [dir=back];'
	queue = [(0, 1, ['!'])]
	while queue:
		(cnt, id, path) = queue.pop(0)
		if id == 1:
			print '\t"!"[label="%s"];' % tree[id].name
		else:
			name = tree[id].name
			if cnt > 1:
				name = '%dx %s' % (cnt, name)
			print '\t"%s"[label="%s"];' % ('/'.join(path), name)
			print '\t"%s" -> "%s";' % ('/'.join(path[:-1]), '/'.join(path))
		queue = map(lambda x: (x[0], x[1], path + [x[1]]), tree[id].using) + queue
	print '}'


def generate_bom(tree):

	try:
		f = open('bom.txt', 'w')
	except:
		error('Cannot create bom.txt')
		return
	f.write('Bill of Materials: %s\n' % tree[1].name)
	f.write((len(tree[1].name) + 19) * '+' + '\n\n')
	queue = [ tree[1].using  ]
	bom = {}
	while queue:
		using = queue.pop(0)
		for (cnt, id) in using:
			if tree[id].category in bom:
				bomcat = bom[tree[id].category]
				if id in bomcat:
					bomcat[id] += cnt
				else:
					bomcat[id] = cnt
			else:
				if tree[id].category:
					bom[tree[id].category] = {}
			queue += [ tree[id].using ]
	for category in bom:
		f.write(category + '\n')
		f.write(len(category) * '=' + '\n')
		for k, v in bom[category].iteritems():
			f.write('- %dx %s\n' % (v, tree[k].name))
		f.write('\n')
	f.write('----\nGenerated by ThingDoc - http://thingdoc.org/\n')
	f.close()

def generate_html(tree):

	try:
		f = open('thingdoc.html', 'w')
	except:
		error('Cannot create thingdoc.html')
		return
	f.write('''<html>
  <head>
    <title>ThingDoc: %s</title>
  </head>
  <body>

    <h1>ThingDoc: %s</h1>

''' % (tree[1].name, tree[1].name)
	)
	f.write('    <h2>Bill of Materials</h2>\n\n')
	queue = [ tree[1].using  ]
	bom = {}
	while queue:
		using = queue.pop(0)
		for (cnt, id) in using:
			if tree[id].category in bom:
				bomcat = bom[tree[id].category]
				if id in bomcat:
					bomcat[id] += cnt
				else:
					bomcat[id] = cnt
			else:
				if tree[id].category:
					bom[tree[id].category] = {}
			queue += [ tree[id].using ]
	for category in bom:
		f.write('    <h3>%s</h3>\n' % category)
		f.write('    <ul>\n')
		for k, v in bom[category].iteritems():
			f.write('      <li>%dx %s</li>\n' % (v, tree[k].name))
		f.write('    </ul>\n\n')
	f.write('''    <p class="footer">Generated by ThingDoc - <a href="http://thingdoc.org/">http://thingdoc.org/</a></p>
  </body>
</html>
''')
	f.close()


def generate_wiki(tree):

	try:
		f = open('thingdoc.wiki', 'w')
	except:
		error('Cannot create thingdoc.wiki')
		return
	f.write('== Bill of Materials ==\n')
	queue = [ tree[1].using  ]
	bom = {}
	while queue:
		using = queue.pop(0)
		for (cnt, id) in using:
			if tree[id].category in bom:
				bomcat = bom[tree[id].category]
				if id in bomcat:
					bomcat[id] += cnt
				else:
					bomcat[id] = cnt
			else:
				if tree[id].category:
					bom[tree[id].category] = {}
			queue += [ tree[id].using ]
	for category in bom:
		f.write("=== %s ===\n{| class=\"wikitable sortable\" border=\"1\"\n|-\n! scope=\"col\" | Quantity\n! scope=\"col\" | Description\n! scope=\"col\" | Type\n! scope=\"col\" class=\"unsortable\" | Comments\n! scope=\"col\" class=\"unsortable\" | Diagram\n" % category)
		for k, v in bom[category].iteritems():
			img = tree[k].image and ' [[File:%s|50px]]' % tree[k].image or ''
			f.write("|-\n| %d || %s || %s || %s ||%s\n" % (v, tree[k].name, tree[k].type, '; '.join(tree[k].comment), img))
		f.write('|}\n')
	f.close()


def generate_tex(tree):

	pass


def main():

	parser = optparse.OptionParser(
		version = '%prog ' + VERSION,
		epilog = 'If none of --bom, --html, --tex, --wiki are provided then all 4 types are generated.')
	parser.add_option('-i', '--indir', dest = 'indir', default = '.', help = 'start scanning in INDIR directory (current by default)', metavar = 'INDIR')
	parser.add_option('-o', '--outdir', dest = 'outdir', default = 'docs', help = 'use OUTDIR as output directory ("docs" by default)', metavar = 'OUTDIR')
	parser.add_option('-b', '--bom', action = 'store_true', dest = 'bom', default = False, help = 'generate Bill of Materials')
	parser.add_option('-m', '--html', action = 'store_true', dest = 'html', default = False, help = 'generate HTML (markup) documentation')
	parser.add_option('-t', '--tex', action = 'store_true', dest = 'tex', default = False, help = 'generate TeX documentation')
	parser.add_option('-w', '--wiki', action = 'store_true', dest = 'wiki', default = False, help = 'generate Wiki documentation')
	parser.add_option('-p', '--print', action = 'store_true', dest = 'tree', default = False, help = 'print tree of things and exit (text mode)')
	parser.add_option('-g', '--graph', action = 'store_true', dest = 'graphviz', default = False, help = 'generate graphviz document')

	(options, _) = parser.parse_args()

	if not options.bom and not options.html and not options.tex and not options.wiki:
		options.bom = options.html = options.tex = options.wiki = True

	tree = generate_tree(options.indir)

	try:
		os.makedirs(options.outdir)
	except:
		pass
	try:
		os.chdir(options.outdir)
	except:
		fatal('Cannot switch to OUTDIR: %s' % options.outdir)

	check_tree(tree)

	if options.tree:
		print_tree(tree)
		return

	if options.graphviz:
		graphviz_tree(tree)
		return

	if options.bom:
		generate_bom(tree)
	if options.html:
		generate_html(tree)
	if options.tex:
		generate_tex(tree)
	if options.wiki:
		generate_wiki(tree)

	print 'All Done!'


if __name__ == '__main__':
	main()
