#!/usr/bin/env python
#
# ThingDoc - things comment parser - http://thingdoc.org/
# Copyright (C) 2011 Josef Prusa <iam@josefprusa.cz>
# Copyright (C) 2011 Pavol Rusnak <stick@gk2.sk>
# See the file AUTHORS for all contributions
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

VERSION = '1.0'

import optparse
import os


class Thing:

	def __init__(self):
		self.id = None          # unique id, root has id = 0 (numeric) which cannot be overriden
		self.name = None        # name of the thing
		self.common = False     # is this thing common?
		self.assembled = False  # is this thing assembled?
		self.category = ''      # category of the thing
		self.type = ''          # type of the thing (more detailed than category, e.g. RP, fastener, etc)
		self.assembly = []      # assembly instructions
		self.since = ''         # since when does the thing exist (can be YYYY-MM-DD or some tag, e.g. "Mendel")
		self.comment = []       # comments
		self.image = None       # if none is specified then images/{id}.jpg is used
		self.using = []         # list of dependencies (their {id}s)
		self.desc = []          # description of the thing


def process_file(absname, things):

	try:
		f = open(absname, 'r')
	except IOError:
		print 'ERROR:   * Cannot open file %s' % absname
		return

	print 'INFO:    * Processing file %s' % absname
	thing = None
	linenum = 0
	for line in f:
		linenum += 1
		if line.startswith('/**'):
			if thing:
				print 'ERROR:   * Found start of the comment (/**) but the previous one is still open (%s:%d) ' % (absname, linenum)
			thing = Thing()
			continue
		if line.startswith(' */'):
			if not thing:
				print 'ERROR:   * Found end of the comment ( */) but there is no previous open one (%s:%d) ' % (absname, linenum)
				continue
			if thing.name == None:
				print 'ERROR:   * Missing mandatory attribute @name (%s:%d)' % (absname, linenum)
			if thing.id != None:
				if things.has_key(thing.id):
					print 'ERROR:   * Duplicate thing id: %s (%s:%d)' % (thing.id, absname, linenum)
				else:
					things[ thing.id ] = thing
			else:
				print 'ERROR:   * Missing mandatory attribute @id (%s:%d)' % (absname, linenum)
			thing = None
			continue
		if not thing:
			continue  # not in a comment
		if not line.startswith(' * '):
			print 'ERROR:   * Comment line does not start with a " * " (%s:%d)' % (absname, linenum)
			continue
		(key, _, value) = line[3:].strip().partition(' ')
		if   key == '@id':
			thing.id = value
		elif key == '@name':
			thing.name = value
		elif key == '@root':
			thing.id = 0
		elif key == '@common':
			thing.common = True
		elif key == '@assembled':
			thing.assembled = True
		elif key == '@since':
			thing.since = value
		elif key == '@category':
			thing.category = value
		elif key == '@type':
			thing.type = value
		elif key == '@assembly':
			thing.assembly.append(value)
		elif key == '@comment':
			thing.comment.append(value)
		elif key == '@image':
			thing.image = value
		elif key == '@using':
			(cnt, _, id) = value.partition(' ')
			thing.using.append( (int(cnt), id) )
		else:
			thing.desc.append(key + ' ' + value)
	f.close()


def generate_tree(indir):

	print 'INFO:  Generating ThingDoc tree'
	things = {}
	for root, dirs, files in os.walk(os.path.abspath(indir)):
		dirs[:] = [d for d in dirs if not d.startswith('.')]
		for name in files:
			# skip if the file is not supported document
			if not os.path.splitext(name)[1] in ['.scad', '.tdoc']:
				continue
			absname = os.path.join(root, name)
			process_file(absname, things)
	return things


def generate_bom(tree):

	print 'INFO:  Generating Bill of Materials'


def generate_html(tree):

	print 'INFO:  Generating HTML documentation'


def generate_tex(tree):

	print 'INFO:  Generating TeX documentation'


def generate_wiki(tree):

	print 'INFO:  Generating Wiki documentation'


def main():

	parser = optparse.OptionParser(
		version = '%prog ' + VERSION,
		epilog = 'If none of --bom, --html, --tex, --wiki are provided then all 4 types are generated.')
	parser.add_option('-i', '--indir', dest = 'indir', default = '.', help = 'start scanning in INDIR directory (current by default)', metavar = 'INDIR')
	parser.add_option('-o', '--outdir', dest = 'outdir', default = 'doc', help = 'use OUTDIR as output directory ("doc" by default)', metavar = 'OUTDIR')
	parser.add_option('-b', '--bom', action = 'store_true', dest = 'bom', default = False, help = "generate Bill of Materials")
	parser.add_option('-m', '--html', action = 'store_true', dest = 'html', default = False, help = "generate HTML (markup) documentation")
	parser.add_option('-t', '--tex', action = 'store_true', dest = 'tex', default = False, help = "generate TeX documentation")
	parser.add_option('-w', '--wiki', action = 'store_true', dest = 'wiki', default = False, help = "generate Wiki documentation")

	(options, _) = parser.parse_args()

	if not options.bom and not options.html and not options.tex and not options.wiki:
		options.bom = options.html = options.tex = options.wiki = True

	tree = generate_tree(options.indir)

	try:
		os.makedirs(options.outdir)
	except:
		pass
	try:
		os.chdir(options.outdir)
	except:
		print 'ERROR: Cannot switch to OUTDIR: %s' % options.outdir

	if options.bom:
		generate_bom(tree)
	if options.html:
		generate_html(tree)
	if options.tex:
		generate_tex(tree)
	if options.wiki:
		generate_wiki(tree)

	print 'INFO:  Finished!'


main()
